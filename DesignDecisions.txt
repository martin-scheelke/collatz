Explanation of decisions and design
===================================

- I focused mainly on the core programming and backend sections (Question 1) as I have little 
  front-end experience.
  
- Used Gradle (dependency management, build and test) and a mix of Java and Kotlin for this solution. 
  Java is my most familiar language and I used Kotlin where Java has limitations - for tail-recursion 
  optimisation and for the ZIP stream function.
  
- Followed a TDD (or close) pattern where tests are written before or during coding.

- I added industrial strength javadoc comments to the Collatz.java and CollatzTail.kt code and 
  more casual comments elsewhere.

- Implemented the Collatz series with recursion in Java. This implementation is not
  tail-recursive and is vulnerable to stack overflow. It also has maximum input, output and intermediate 
  term values of Long.MAX_VALUE (2^63-1). 

- Implemented the Collatz series with tail-recursion in Kotlin which optimises tail-recursive functions.
  Used BigInteger for the input, output and intermediate term values. This allows arbitrarily large 
  series tests without risk of stack overflow or number out of range problems.                

- Dot product implemented and tested in Kotlin making use of ZIP, MAP and REDUCE.

- I chose Spark Java (sparkjava.com) as the HTTP server framework for building the REST API Controller. 
  It is a lightweight framework/library which can be dropped into the application. I prefer this over 
  heavier enterprise frameworks such as Spring Boot where possible (although I'm happy to use 
  Spring Boot when required). Spark has low memory usage , see: 
  https://craftsmen.nl/memory-usage-6-popular-rest-server-frameworks-compared/ 
  and has performance comparable to it's underlying Jetty server. 
  If required, the Controller implementation can be swapped out with another server implementation 
  without affecting the rest of the implementation.
  
- I chose the REST Assured test framework for integration testing of the REST API. The syntax is 
  readable, concise and declarative and the tests can be automated as plain JUnit tests and run 
  with Gradle.
  
- Collatz term calculations are delegated to a Thread Pool Executor and I chose a synchronised 
  Map for caching results as this allows safe multi-threaded access. 
  
- Added collatz.database persistence using a persistent version of the collatz calculation service

- Postgres Database version management is by flyway - collatz.database access is by jOOQ DSL using
  a Hikari datasource with a transactional wrapper. I chose jOOQ DSL as it gives typesafe query construction
  and sometimes allows construction of complex queries more easily than ORM.  
  
- The service implementation is injected at runtime and access via and interface. This is and example
  of the dependency inversion principle. The service implementation can be select using a property 
  and be set to use in-memory caching or persistence.

- A custom jOOQ transaction wrapper wraps all calculation code and collatz.database code for each persistent
  service call. To be clear the Collatz calculation code AND the collatz.database call are all wrapped in one
  transaction. This allows complete rollback and undoing of state over multiple collatz.database calls if needed.
  
- Used CircleCI with a docker build for CI/CT integration - very easy to setup...

Further possible improvements
=============================

- The throughput of Collatz calculation results could potentially be improved by tuning the number of 
  threads in the Executor Thread Pool. This would be a trade-off in competition with client/server
  connection/thread resources.
  
- The Collatz algorithm itself could be optimised by caching and reusing interim steps. 

- Parameter type validation on the REST API. 

- Gradle collatz.task separation of integration tests.